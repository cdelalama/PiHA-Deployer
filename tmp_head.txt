#!/bin/bash
set -e

# Version
VERSION="1.0.67"

# Define colors
BLUE='\033[0;36m'  # Lighter blue (cyan)
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color


# Function to clean up existing installations
cleanup_existing() {
    echo -e "${BLUE}Cleaning up existing installations...${NC}"

    # Check if Docker is installed and running
    if command -v docker &> /dev/null && docker info &> /dev/null; then
        echo "Stopping and removing existing containers..."
        docker-compose down 2>/dev/null || true
        docker rm -f portainer node-red syncthing 2>/dev/null || true

        echo "Pruning Docker system..."
        docker system prune -f 2>/dev/null || true
    fi

    # Clean up directories if they exist
    if [ -d "/srv/docker" ]; then
        echo "Cleaning up /srv/docker directory..."
        sudo rm -rf /srv/docker/* 2>/dev/null || true
    fi

    # Recreate directories with proper permissions
    echo "Creating fresh directories..."
    sudo mkdir -p /srv/docker/portainer /srv/docker/node-red /srv/docker/syncthing
    sudo chown -R 1000:1000 /srv/docker/node-red
    sudo chown -R 1000:1000 /srv/docker/portainer
    sudo chown -R 1000:1000 /srv/docker/syncthing

    echo -e "${GREEN}Cleanup completed successfully${NC}"
}

# Add this after version and before starting the main script
echo -e "${BLUE}PiHA-Deployer Node-RED Install Script v$VERSION${NC}"
echo "Script started"

# Ask for cleanup with countdown and default to "Y"
echo -e "${BLUE}ðŸ¤” Do you want to clean up any existing installations? (Y/n)${NC}"
echo -n "Automatically continuing with 'Y' in "

# Initialize cleanup_choice
cleanup_choice=""

# Start countdown with input check
for i in {5..1}; do
    echo -n "$i... "
    if read -t 1 -n 1 input; then
        # Accept Enter (empty input) or Y/y/N/n
        if [[ -z "$input" || "$input" =~ ^[YyNn]$ ]]; then
            cleanup_choice="${input:-y}"  # Use 'y' if input is empty (Enter key)
            echo # New line after input
            break
        fi
    fi
done

# If no valid input received, default to "y"
if [[ ! "$cleanup_choice" =~ ^[YyNn]$ ]]; then
    cleanup_choice="y"
    echo # New line after countdown
    echo "No valid input received, using default: Yes"
fi

# Perform cleanup if choice is "y"
if [[ "$cleanup_choice" =~ ^[Yy]$ ]]; then
    cleanup_existing
fi

# Install necessary packages
echo -e "${BLUE}Installing necessary packages...${NC}" >&2
sudo apt-get update
sudo apt-get install -y smbclient cifs-utils

# GitHub repository details
REPO_OWNER="cdelalama"
REPO_NAME="PiHA-Deployer"
BRANCH="main"

# Function to get version from file
get_version() {
    local file=$1
    local version=$(grep "^VERSION=" "$file" | cut -d'"' -f2)
    echo "$version"
}

# Function to download a file from GitHub
download_from_github() {
    local file=$1
    local temp_file="/tmp/${file}"

    echo -e "${BLUE}Checking for updates to $file...${NC}" >&2

    # Try to get GitHub version
    if ! curl -sSL -o "$temp_file" "https://raw.githubusercontent.com/$REPO_OWNER/$REPO_NAME/$BRANCH/node-red/$file"; then
        # If file exists locally
        if [ -f "$file" ]; then
            local local_version=$(get_version "$file")
            echo -e "${GREEN}âœ“ Using local $file${NC}" >&2
            [ ! -z "$local_version" ] && echo -e "${BLUE}Version: $local_version${NC}" >&2
            rm -f "$temp_file"
            return 0
        else
            echo -e "${RED}âœ— File not found locally or on GitHub${NC}" >&2
            rm -f "$temp_file"
            return 1
        fi
    fi

    # Check if the downloaded file is valid
    if head -n 1 "$temp_file" | grep -q "404:"; then
        echo -e "${RED}âœ— Invalid file downloaded from GitHub${NC}" >&2
        rm -f "$temp_file"

        # If file exists locally
        if [ -f "$file" ]; then
            local local_version=$(get_version "$file")
            echo -e "${GREEN}âœ“ Using local $file instead${NC}" >&2
            [ ! -z "$local_version" ] && echo -e "${BLUE}Version: $local_version${NC}" >&2
            return 0
        else
            echo -e "${RED}âœ— Valid file not found locally or on GitHub${NC}" >&2
            return 1
        fi
    fi

    local remote_version=$(get_version "$temp_file")

    # If file exists locally
    if [ -f "$file" ]; then
        local local_version=$(get_version "$file")

        # Compare versions if both exist
        if [ ! -z "$local_version" ] && [ ! -z "$remote_version" ]; then
            if [[ "$(printf '%s\n' "$remote_version" "$local_version" | sort -V | tail -n1)" == "$local_version" ]]; then
                echo -e "${GREEN}âœ“ Local version is up to date ($local_version)${NC}" >&2
                rm -f "$temp_file"
                return 0
            else
                echo -e "${BLUE}â†‘ Updating from $local_version to $remote_version${NC}" >&2
                mv "$temp_file" "$file"
            fi
        else
            echo -e "${BLUE}â†‘ Updating to latest version${NC}" >&2
            mv "$temp_file" "$file"
        fi
    else
        echo -e "${BLUE}â¤“ Downloading $file...${NC}" >&2
        mv "$temp_file" "$file"
        echo -e "${GREEN}âœ“ Download complete${NC}" >&2
    fi
}

# Check if load_env_vars.sh exists in the current directory
if [ -f "load_env_vars.sh" ]; then
    echo -e "${GREEN}load_env_vars.sh already exists in the current directory${NC}"
fi

# Check for a newer version on GitHub
if download_from_github "load_env_vars.sh"; then
    # If download_from_github returned 0, it means the file was downloaded from GitHub
    # or the local version is up to date. In either case, we can proceed.

    # Make load_env_vars.sh executable
    chmod +x load_env_vars.sh

    # Source load_env_vars.sh
    source load_env_vars.sh
else
    # If download_from_github returned non-zero, it means the file doesn't exist on GitHub
    # or there was an error during the download.
    echo -e "${YELLOW}âš  load_env_vars.sh not found on GitHub${NC}" >&2

    # Check if the file exists locally
    if [ -f "load_env_vars.sh" ]; then
        echo -e "${BLUE}Using local version of load_env_vars.sh${NC}"

        # Make load_env_vars.sh executable
        chmod +x load_env_vars.sh

        # Source load_env_vars.sh
        source load_env_vars.sh
    else
        echo -e "${RED}âœ— load_env_vars.sh not found locally or on GitHub${NC}" >&2
        echo -e "${YELLOW}Continuing without load_env_vars.sh...${NC}"
    fi
fi

# Verify NAS connectivity and parameters
  echo -e "${BLUE}Verifying NAS connection parameters...${NC}"

